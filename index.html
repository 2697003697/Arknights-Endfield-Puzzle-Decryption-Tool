<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>终末地拼图求解工具</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #d4c4b5 0%, #b8a99a 100%);
            min-height: 100vh;
            padding: 20px;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: #fdfcfa;
            border-radius: 12px;
            padding: 30px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.1);
        }
        h1 {
            text-align: center;
            color: #6b5b4f;
            margin-bottom: 30px;
            font-size: 2em;
            font-weight: 600;
            letter-spacing: 1px;
        }
        .main-layout {
            display: grid;
            grid-template-columns: 1fr 350px;
            gap: 25px;
        }
        .left-panel {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        .right-panel {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        .section {
            background: #ffffff;
            border-radius: 8px;
            padding: 20px;
            border: 1px solid #e8e0d8;
            box-shadow: 0 2px 4px rgba(0,0,0,0.03);
        }
        .section-title {
            font-size: 1.1em;
            color: #7a6a5a;
            margin-bottom: 15px;
            font-weight: 600;
            border-bottom: 2px solid #e8e0d8;
            padding-bottom: 8px;
        }
        .grid-settings {
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
        }
        .input-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .input-group label {
            font-weight: 500;
            color: #8a7a6a;
            font-size: 14px;
        }
        input[type="number"] {
            width: 65px;
            padding: 8px 10px;
            border: 1px solid #d8d0c8;
            border-radius: 6px;
            font-size: 14px;
            text-align: center;
            background: #faf8f5;
            transition: border-color 0.2s;
        }
        input[type="number"]:focus {
            outline: none;
            border-color: #a89888;
        }
        button {
            padding: 10px 18px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            transition: all 0.2s ease;
        }
        .btn-primary {
            background: linear-gradient(135deg, #a8b8c8 0%, #8898a8 100%);
            color: white;
        }
        .btn-primary:hover {
            background: linear-gradient(135deg, #8898a8 0%, #687888 100%);
            box-shadow: 0 4px 12px rgba(104, 120, 136, 0.3);
        }
        .btn-secondary {
            background: #c8b8a8;
            color: white;
        }
        .btn-secondary:hover {
            background: #b8a898;
        }
        .btn-success {
            background: linear-gradient(135deg, #a8c8b8 0%, #88a898 100%);
            color: white;
        }
        .btn-success:hover {
            background: linear-gradient(135deg, #88a898 0%, #688878 100%);
            box-shadow: 0 4px 12px rgba(104, 136, 120, 0.3);
        }
        .btn-danger {
            background: #d4a8a8;
            color: white;
        }
        .btn-danger:hover {
            background: #c89898;
        }
        .btn-small {
            padding: 5px 12px;
            font-size: 12px;
        }
        .grid-container {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            overflow: auto;
            padding: 10px;
        }
        .grid-wrapper {
            display: flex;
        }
        .corner-cell {
            width: 80px;
            height: 60px;
        }
        .col-headers {
            display: flex;
        }
        .col-header {
            width: 40px;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: linear-gradient(135deg, #e8e0d8 0%, #d8d0c8 100%);
            border: 1px solid #d0c8c0;
            font-weight: 600;
            color: #7a6a5a;
        }
        .row-headers {
            display: flex;
            flex-direction: column;
        }
        .row-header {
            width: 80px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: linear-gradient(135deg, #e8e0d8 0%, #d8d0c8 100%);
            border: 1px solid #d0c8c0;
            font-weight: 600;
            color: #7a6a5a;
        }
        .grid {
            display: grid;
            gap: 1px;
            background: #d8d0c8;
            border: 2px solid #c8c0b8;
        }
        .cell {
            width: 40px;
            height: 40px;
            background: white;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.15s ease;
            font-size: 12px;
            font-weight: 500;
            user-select: none;
        }
        .cell:hover {
            background: #faf8f5;
        }
        .cell.filled {
            background: #a89888;
        }
        .cell.obstacle {
            background: repeating-linear-gradient(
                45deg,
                #c8c0b8,
                #c8c0b8 5px,
                #b8b0a8 5px,
                #b8b0a8 10px
            );
            border: 2px solid #a89888;
        }
        .cell.pre-filled {
            background: repeating-linear-gradient(
                -45deg,
                #a8c8b8,
                #a8c8b8 5px,
                #88b8a8 5px,
                #88b8a8 10px
            );
            border: 2px solid #689888;
        }
        .grid-edit-mode {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            padding: 10px;
            background: #faf8f5;
            border-radius: 6px;
            flex-wrap: wrap;
        }
        .grid-mode-btn {
            padding: 8px 16px;
            border: 1px solid #d8d0c8;
            background: white;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            color: #7a6a5a;
            transition: all 0.2s ease;
        }
        .grid-mode-btn:hover {
            border-color: #c8c0b8;
            background: #faf8f5;
        }
        .grid-mode-btn.active {
            background: linear-gradient(135deg, #a8b8c8 0%, #8898a8 100%);
            color: white;
            border-color: #8898a8;
        }
        .grid-mode-btn.obstacle-mode.active {
            background: linear-gradient(135deg, #c8c0b8 0%, #b8b0a8 100%);
            border-color: #b8b0a8;
        }
        .grid-mode-btn.pre-filled-mode.active {
            background: linear-gradient(135deg, #a8c8b8 0%, #88b8a8 100%);
            border-color: #88b8a8;
        }
        .grid-legend {
            display: flex;
            gap: 20px;
            margin-top: 10px;
            font-size: 12px;
            color: #8a7a6a;
            flex-wrap: wrap;
        }
        .grid-legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .grid-legend-box {
            width: 16px;
            height: 16px;
            border-radius: 3px;
        }
        .cell.piece-1 { background: linear-gradient(135deg, #e8b4b4 0%, #d4a0a0 100%); border: 2px solid #c09090; }
        .cell.piece-2 { background: linear-gradient(135deg, #b4d4c8 0%, #a0c4b8 100%); border: 2px solid #90b4a8; }
        .cell.piece-3 { background: linear-gradient(135deg, #b4c8e8 0%, #a0b8d4 100%); border: 2px solid #90a8c4; }
        .cell.piece-4 { background: linear-gradient(135deg, #e8d4b4 0%, #d4c4a0 100%); border: 2px solid #c4b490; }
        .cell.piece-5 { background: linear-gradient(135deg, #d4b4e8 0%, #c4a0d4 100%); border: 2px solid #b490c4; }
        .cell.piece-6 { background: linear-gradient(135deg, #b4e8d4 0%, #a0d4c4 100%); border: 2px solid #90c4b4; }
        .cell.piece-7 { background: linear-gradient(135deg, #e8c8b4 0%, #d4b8a0 100%); border: 2px solid #c4a890; }
        .cell.piece-8 { background: linear-gradient(135deg, #b4d4e8 0%, #a0c4d4 100%); border: 2px solid #90b4c4; }
        .cell.piece-9 { background: linear-gradient(135deg, #d4e8b4 0%, #c4d4a0 100%); border: 2px solid #b4c490; }
        .cell.piece-10 { background: linear-gradient(135deg, #e8b4d4 0%, #d4a0c4 100%); border: 2px solid #c490b4; }
        .cell.piece-11 { background: linear-gradient(135deg, #b4e8c8 0%, #a0d4b8 100%); border: 2px solid #90c4a8; }
        .cell.piece-12 { background: linear-gradient(135deg, #c8b4e8 0%, #b8a0d4 100%); border: 2px solid #a890c4; }
        .puzzle-list {
            display: flex;
            flex-direction: column;
            gap: 12px;
            max-height: 400px;
            overflow-y: auto;
        }
        .puzzle-item {
            background: #faf8f5;
            border-radius: 6px;
            padding: 12px;
            border: 1px solid #e8e0d8;
        }
        .puzzle-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }
        .puzzle-name {
            font-weight: 600;
            color: #7a6a5a;
            font-size: 14px;
        }
        .puzzle-grid {
            display: grid;
            gap: 2px;
            background: #d8d0c8;
            margin-bottom: 8px;
        }
        .puzzle-cell {
            width: 25px;
            height: 25px;
            background: white;
            cursor: crosshair;
            border: 1px solid #e8e0d8;
            user-select: none;
        }
        .puzzle-cell.active {
            background: #a89888;
        }
        .puzzle-cell:hover {
            border-color: #a89888;
        }
        .puzzle-editor-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            padding: 10px;
            background: #faf8f5;
            border-radius: 6px;
        }
        .puzzle-canvas-wrapper {
            position: relative;
            background: white;
            border: 1px solid #e8e0d8;
            border-radius: 6px;
            padding: 10px;
        }
        .puzzle-canvas {
            display: grid;
            gap: 1px;
            background: #d8d0c8;
        }
        .puzzle-canvas-cell {
            width: 30px;
            height: 30px;
            background: white;
            cursor: crosshair;
            user-select: none;
        }
        .puzzle-canvas-cell.filled {
            background: #a89888;
        }
        .puzzle-canvas-cell:hover {
            background: #faf8f5;
        }
        .puzzle-preview {
            display: inline-block;
            background: white;
            border: 1px solid #e8e0d8;
            border-radius: 4px;
            padding: 5px;
        }
        .puzzle-preview-grid {
            display: grid;
            gap: 1px;
            background: #d8d0c8;
        }
        .puzzle-preview-cell {
            width: 15px;
            height: 15px;
            background: white;
        }
        .puzzle-preview-cell.filled {
            background: #a89888;
        }
        .drawing-mode {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }
        .mode-btn {
            padding: 6px 14px;
            border: 1px solid #d8d0c8;
            background: white;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 500;
            color: #7a6a5a;
        }
        .mode-btn:hover {
            border-color: #c8c0b8;
        }
        .mode-btn.active {
            background: #a89888;
            color: white;
            border-color: #a89888;
        }
        .canvas-size-controls {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-bottom: 10px;
        }
        .puzzle-actions {
            display: flex;
            gap: 5px;
        }
        .add-puzzle-form {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #e8e0d8;
        }
        .form-row {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        .result-section {
            margin-top: 20px;
            padding: 20px;
            background: linear-gradient(135deg, #f0f8f4 0%, #e8f0ec 100%);
            border-radius: 8px;
            border: 1px solid #a8d4b8;
            display: none;
        }
        .result-section.show {
            display: block;
        }
        .result-title {
            font-size: 1.1em;
            color: #5a8a6a;
            margin-bottom: 15px;
            font-weight: 600;
        }
        .result-grid {
            display: grid;
            gap: 2px;
            background: #d8d0c8;
            margin-top: 15px;
        }
        .result-cell {
            width: 40px;
            height: 40px;
            background: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: 600;
            color: white;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.2);
            border-radius: 4px;
            box-shadow: inset 0 1px 2px rgba(255,255,255,0.3), 0 1px 2px rgba(0,0,0,0.05);
        }
        .result-cell.piece-1 { background: linear-gradient(135deg, #e8b4b4 0%, #d4a0a0 100%); }
        .result-cell.piece-2 { background: linear-gradient(135deg, #b4d4c8 0%, #a0c4b8 100%); }
        .result-cell.piece-3 { background: linear-gradient(135deg, #b4c8e8 0%, #a0b8d4 100%); }
        .result-cell.piece-4 { background: linear-gradient(135deg, #e8d4b4 0%, #d4c4a0 100%); }
        .result-cell.piece-5 { background: linear-gradient(135deg, #d4b4e8 0%, #c4a0d4 100%); }
        .result-cell.piece-6 { background: linear-gradient(135deg, #b4e8d4 0%, #a0d4c4 100%); }
        .result-cell.piece-7 { background: linear-gradient(135deg, #e8c8b4 0%, #d4b8a0 100%); }
        .result-cell.piece-8 { background: linear-gradient(135deg, #b4d4e8 0%, #a0c4d4 100%); }
        .result-cell.piece-9 { background: linear-gradient(135deg, #d4e8b4 0%, #c4d4a0 100%); }
        .result-cell.piece-10 { background: linear-gradient(135deg, #e8b4d4 0%, #d4a0c4 100%); }
        .result-cell.piece-11 { background: linear-gradient(135deg, #b4e8c8 0%, #a0d4b8 100%); }
        .result-cell.piece-12 { background: linear-gradient(135deg, #c8b4e8 0%, #b8a0d4 100%); }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 14px;
            background: white;
            border-radius: 20px;
            border: 1px solid #e8e0d8;
            font-size: 13px;
            font-weight: 500;
            color: #7a6a5a;
        }
        .legend-color {
            width: 18px;
            height: 18px;
            border-radius: 4px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        .status-message {
            padding: 10px 15px;
            border-radius: 6px;
            margin-top: 10px;
            font-weight: 500;
            font-size: 13px;
        }
        .status-success {
            background: #d4e8dc;
            color: #5a8a6a;
            border: 1px solid #a8d4b8;
        }
        .status-error {
            background: #f0d4d4;
            color: #b86868;
            border: 1px solid #e0a8a8;
        }
        .status-info {
            background: #d4e0f0;
            color: #6888a8;
            border: 1px solid #a8c0e0;
        }
        .editable {
            cursor: text;
            padding: 5px;
            border: 1px dashed #c8c0b8;
            min-width: 30px;
            text-align: center;
            border-radius: 4px;
        }
        .editable:focus {
            outline: none;
            border-color: #a89888;
            background: white;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>求解工具</h1>
        
        <div class="main-layout">
            <div class="left-panel">
                <div class="section">
                    <div class="section-title">网格设置</div>
                    <div class="grid-settings">
                        <div class="input-group">
                            <label>行数:</label>
                            <input type="number" id="rows" value="5" min="1" max="20">
                        </div>
                        <div class="input-group">
                            <label>列数:</label>
                            <input type="number" id="cols" value="5" min="1" max="20">
                        </div>
                        <button class="btn-primary" onclick="createGrid()">创建网格</button>
                        <button class="btn-secondary" onclick="clearGrid()">清空</button>
                    </div>
                </div>

                <div class="section">
                    <div class="section-title">题目编辑</div>
                    <div class="grid-edit-mode">
                        <button class="grid-mode-btn active" id="modeNormal" onclick="setGridMode('normal')">编辑约束</button>
                        <button class="grid-mode-btn obstacle-mode" id="modeObstacle" onclick="setGridMode('obstacle')">障碍物</button>
                        <button class="grid-mode-btn pre-filled-mode" id="modePreFilled" onclick="setGridMode('preFilled')">预填拼图</button>
                        <button class="btn-secondary btn-small" onclick="clearGridCells()">清空格子</button>
                    </div>
                    <div class="grid-legend">
                        <div class="grid-legend-item">
                            <div class="grid-legend-box" style="background: repeating-linear-gradient(45deg, #c8c0b8, #c8c0b8 3px, #b8b0a8 3px, #b8b0a8 6px); border: 1px solid #a89888;"></div>
                            <span>障碍物（不能被覆盖）</span>
                        </div>
                        <div class="grid-legend-item">
                            <div class="grid-legend-box" style="background: repeating-linear-gradient(-45deg, #a8c8b8, #a8c8b8 3px, #88b8a8 3px, #88b8a8 6px); border: 1px solid #689888;"></div>
                            <span>预填拼图（算入拼图数量）</span>
                        </div>
                    </div>
                    <div class="grid-container" id="gridContainer">
                        <p style="color: #8a7a6a; text-align: center;">请先创建网格</p>
                    </div>
                </div>

                <div class="section result-section" id="resultSection">
                    <div class="result-title">求解结果</div>
                    <div id="resultContainer"></div>
                </div>
            </div>

            <div class="right-panel">
                <div class="section">
                    <div class="section-title">拼图管理</div>
                    <div class="puzzle-list" id="puzzleList"></div>
                    
                    <div class="add-puzzle-form">
                        <div class="canvas-size-controls">
                            <div class="input-group">
                                <label>画布宽:</label>
                                <input type="number" id="canvasWidth" value="5" min="3" max="10">
                            </div>
                            <div class="input-group">
                                <label>画布高:</label>
                                <input type="number" id="canvasHeight" value="5" min="3" max="10">
                            </div>
                            <button class="btn-secondary btn-small" onclick="updateCanvasSize()">调整</button>
                        </div>
                        <div class="drawing-mode">
                            <button class="mode-btn active" id="drawMode" onclick="setDrawMode('draw')">绘制</button>
                            <button class="mode-btn" id="eraseMode" onclick="setDrawMode('erase')">擦除</button>
                        </div>
                        <div class="puzzle-editor-container">
                            <div class="puzzle-canvas-wrapper">
                                <div id="puzzleCanvas" class="puzzle-canvas"></div>
                            </div>
                        </div>
                        <button class="btn-primary" onclick="addPuzzleFromCanvas()">添加拼图</button>
                    </div>
                </div>

                <div class="section">
                    <div class="section-title">操作</div>
                    <button class="btn-success" onclick="solvePuzzle()" style="width: 100%; margin-bottom: 10px;">开始求解</button>
                    <button class="btn-danger" onclick="clearAll()" style="width: 100%;">全部清空</button>
                    <div id="statusMessage"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let gridData = {
            rows: 0,
            cols: 0,
            rowConstraints: [],
            colConstraints: [],
            obstacles: [],
            preFilled: []
        };
        let puzzles = [];
        let canvasData = {
            width: 5,
            height: 5,
            cells: []
        };
        let drawMode = 'draw';
        let isDrawing = false;
        let gridEditMode = 'normal';
        let isGridEditing = false;

        function createGrid() {
            const rows = parseInt(document.getElementById('rows').value);
            const cols = parseInt(document.getElementById('cols').value);
            
            gridData.rows = rows;
            gridData.cols = cols;
            gridData.rowConstraints = new Array(rows).fill(0);
            gridData.colConstraints = new Array(cols).fill(0);
            gridData.obstacles = Array(rows).fill(null).map(() => Array(cols).fill(false));
            gridData.preFilled = Array(rows).fill(null).map(() => Array(cols).fill(false));
            
            renderGrid();
            showStatus('网格已创建', 'info');
        }

        function renderGrid() {
            const container = document.getElementById('gridContainer');
            const rows = gridData.rows;
            const cols = gridData.cols;
            
            let html = '<div class="grid-wrapper">';
            html += '<div>';
            html += '<div class="corner-cell"></div>';
            html += '<div class="row-headers">';
            for (let i = 0; i < rows; i++) {
                html += `<div class="row-header editable" contenteditable="true" 
                    onblur="updateRowConstraint(${i}, this.innerText)">${gridData.rowConstraints[i]}</div>`;
            }
            html += '</div></div>';
            
            html += '<div>';
            html += '<div class="col-headers">';
            for (let j = 0; j < cols; j++) {
                html += `<div class="col-header editable" contenteditable="true"
                    onblur="updateColConstraint(${j}, this.innerText)">${gridData.colConstraints[j]}</div>`;
            }
            html += '</div>';
            
            html += `<div class="grid" style="grid-template-columns: repeat(${cols}, 40px);" 
                onmouseleave="endGridEdit()" onmouseup="endGridEdit()">`;
            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < cols; j++) {
                    let cellClass = 'cell';
                    if (gridData.obstacles[i][j]) cellClass += ' obstacle';
                    if (gridData.preFilled[i][j]) cellClass += ' pre-filled';
                    html += `<div class="${cellClass}" id="cell-${i}-${j}" 
                        data-row="${i}" data-col="${j}"
                        onmousedown="startGridEdit(event, ${i}, ${j})"
                        onmouseenter="continueGridEdit(event, ${i}, ${j})"
                        onmouseup="endGridEdit()"></div>`;
                }
            }
            html += '</div></div></div>';
            
            container.innerHTML = html;
        }

        function setGridMode(mode) {
            gridEditMode = mode;
            document.getElementById('modeNormal').classList.toggle('active', mode === 'normal');
            document.getElementById('modeObstacle').classList.toggle('active', mode === 'obstacle');
            document.getElementById('modePreFilled').classList.toggle('active', mode === 'preFilled');
        }

        let lastToggledCell = null;

        function startGridEdit(event, row, col) {
            if (gridEditMode === 'normal') return;
            event.preventDefault();
            isGridEditing = true;
            lastToggledCell = `${row},${col}`;
            toggleGridCell(row, col, true);
        }

        function continueGridEdit(event, row, col) {
            if (!isGridEditing || gridEditMode === 'normal') return;
            event.preventDefault();
            const cellKey = `${row},${col}`;
            if (cellKey !== lastToggledCell) {
                lastToggledCell = cellKey;
                toggleGridCell(row, col, false);
            }
        }

        function endGridEdit() {
            isGridEditing = false;
            lastToggledCell = null;
        }

        function toggleGridCell(row, col, isClick) {
            if (gridEditMode === 'obstacle') {
                const newValue = isClick ? !gridData.obstacles[row][col] : true;
                gridData.obstacles[row][col] = newValue;
                if (gridData.obstacles[row][col]) {
                    gridData.preFilled[row][col] = false;
                }
            } else if (gridEditMode === 'preFilled') {
                const newValue = isClick ? !gridData.preFilled[row][col] : true;
                gridData.preFilled[row][col] = newValue;
                if (gridData.preFilled[row][col]) {
                    gridData.obstacles[row][col] = false;
                }
            }
            renderGrid();
        }

        function clearGridCells() {
            gridData.obstacles = Array(gridData.rows).fill(null).map(() => Array(gridData.cols).fill(false));
            gridData.preFilled = Array(gridData.rows).fill(null).map(() => Array(gridData.cols).fill(false));
            renderGrid();
            showStatus('格子已清空', 'info');
        }

        function updateRowConstraint(row, value) {
            const num = parseInt(value) || 0;
            gridData.rowConstraints[row] = Math.max(0, Math.min(num, gridData.cols));
        }

        function updateColConstraint(col, value) {
            const num = parseInt(value) || 0;
            gridData.colConstraints[col] = Math.max(0, Math.min(num, gridData.rows));
        }

        function clearGrid() {
            gridData.rowConstraints = new Array(gridData.rows).fill(0);
            gridData.colConstraints = new Array(gridData.cols).fill(0);
            renderGrid();
            document.getElementById('resultSection').classList.remove('show');
        }

        function initCanvas() {
            canvasData.width = parseInt(document.getElementById('canvasWidth').value);
            canvasData.height = parseInt(document.getElementById('canvasHeight').value);
            canvasData.cells = Array(canvasData.height).fill(null).map(() => Array(canvasData.width).fill(false));
            renderCanvas();
        }

        function renderCanvas() {
            const canvas = document.getElementById('puzzleCanvas');
            canvas.style.gridTemplateColumns = `repeat(${canvasData.width}, 30px)`;
            
            let html = '';
            for (let i = 0; i < canvasData.height; i++) {
                for (let j = 0; j < canvasData.width; j++) {
                    const filled = canvasData.cells[i][j] ? 'filled' : '';
                    html += `<div class="puzzle-canvas-cell ${filled}" 
                        data-row="${i}" data-col="${j}"
                        onmousedown="startDraw(event, ${i}, ${j})"
                        onmouseenter="continueDraw(event, ${i}, ${j})"
                        onmouseup="endDraw()"
                        onmouseleave="endDraw()"
                        ontouchstart="startDraw(event, ${i}, ${j})"
                        ontouchmove="handleTouch(event)"
                        ontouchend="endDraw()"></div>`;
                }
            }
            canvas.innerHTML = html;
        }

        function updateCanvasSize() {
            const newWidth = parseInt(document.getElementById('canvasWidth').value);
            const newHeight = parseInt(document.getElementById('canvasHeight').value);
            
            const newCells = Array(newHeight).fill(null).map(() => Array(newWidth).fill(false));
            
            for (let i = 0; i < Math.min(canvasData.height, newHeight); i++) {
                for (let j = 0; j < Math.min(canvasData.width, newWidth); j++) {
                    newCells[i][j] = canvasData.cells[i][j];
                }
            }
            
            canvasData.width = newWidth;
            canvasData.height = newHeight;
            canvasData.cells = newCells;
            renderCanvas();
        }

        function setDrawMode(mode) {
            drawMode = mode;
            document.getElementById('drawMode').classList.toggle('active', mode === 'draw');
            document.getElementById('eraseMode').classList.toggle('active', mode === 'erase');
        }

        function startDraw(event, row, col) {
            event.preventDefault();
            isDrawing = true;
            toggleCanvasCell(row, col);
        }

        function continueDraw(event, row, col) {
            if (isDrawing) {
                event.preventDefault();
                const shouldFill = drawMode === 'draw';
                if (canvasData.cells[row][col] !== shouldFill) {
                    toggleCanvasCell(row, col);
                }
            }
        }

        function endDraw() {
            isDrawing = false;
        }

        function handleTouch(event) {
            event.preventDefault();
            const touch = event.touches[0];
            const element = document.elementFromPoint(touch.clientX, touch.clientY);
            if (element && element.classList.contains('puzzle-canvas-cell')) {
                const row = parseInt(element.dataset.row);
                const col = parseInt(element.dataset.col);
                if (isDrawing) {
                    const shouldFill = drawMode === 'draw';
                    if (canvasData.cells[row][col] !== shouldFill) {
                        toggleCanvasCell(row, col);
                    }
                }
            }
        }

        function toggleCanvasCell(row, col) {
            canvasData.cells[row][col] = drawMode === 'draw';
            renderCanvas();
        }

        function addPuzzleFromCanvas() {
            const cells = [];
            let minRow = canvasData.height, minCol = canvasData.width;
            let maxRow = -1, maxCol = -1;
            
            for (let i = 0; i < canvasData.height; i++) {
                for (let j = 0; j < canvasData.width; j++) {
                    if (canvasData.cells[i][j]) {
                        cells.push({r: i, c: j});
                        minRow = Math.min(minRow, i);
                        minCol = Math.min(minCol, j);
                        maxRow = Math.max(maxRow, i);
                        maxCol = Math.max(maxCol, j);
                    }
                }
            }
            
            if (cells.length === 0) {
                showStatus('请先在画布上绘制拼图形状', 'error');
                return;
            }
            
            const height = maxRow - minRow + 1;
            const width = maxCol - minCol + 1;
            const shape = Array(height).fill(null).map(() => Array(width).fill(false));
            
            cells.forEach(cell => {
                shape[cell.r - minRow][cell.c - minCol] = true;
            });
            
            const puzzle = {
                id: puzzles.length,
                width: width,
                height: height,
                shape: shape
            };
            puzzles.push(puzzle);
            
            canvasData.cells = Array(canvasData.height).fill(null).map(() => Array(canvasData.width).fill(false));
            renderCanvas();
            renderPuzzleList();
            showStatus('拼图已添加', 'success');
        }

        function renderPuzzleList() {
            const container = document.getElementById('puzzleList');
            let html = '';
            
            puzzles.forEach((puzzle, index) => {
                const cellCount = getPuzzleCells(puzzle).length;
                html += `<div class="puzzle-item">
                    <div class="puzzle-header">
                        <span class="puzzle-name">拼图 ${index + 1} <small style="color: #888;">(${cellCount}格)</small></span>
                        <button class="btn-danger btn-small" onclick="removePuzzle(${index})">删除</button>
                    </div>
                    <div class="puzzle-preview">
                        <div class="puzzle-preview-grid" style="grid-template-columns: repeat(${puzzle.width}, 15px);">
                            ${generatePuzzlePreviewHtml(puzzle)}
                        </div>
                    </div>
                    <div class="puzzle-actions">
                        <button class="btn-secondary btn-small" onclick="rotatePuzzle(${index})">旋转</button>
                        <button class="btn-secondary btn-small" onclick="editPuzzle(${index})">编辑</button>
                    </div>
                </div>`;
            });
            
            container.innerHTML = html;
        }

        function generatePuzzlePreviewHtml(puzzle) {
            let html = '';
            for (let i = 0; i < puzzle.height; i++) {
                for (let j = 0; j < puzzle.width; j++) {
                    const filled = puzzle.shape[i][j] ? 'filled' : '';
                    html += `<div class="puzzle-preview-cell ${filled}"></div>`;
                }
            }
            return html;
        }

        function editPuzzle(index) {
            const puzzle = puzzles[index];
            
            document.getElementById('canvasWidth').value = puzzle.width;
            document.getElementById('canvasHeight').value = puzzle.height;
            
            canvasData.width = puzzle.width;
            canvasData.height = puzzle.height;
            canvasData.cells = puzzle.shape.map(row => [...row]);
            
            renderCanvas();
            removePuzzle(index);
            showStatus('拼图已加载到画布，编辑后请重新添加', 'info');
        }

        function rotatePuzzle(puzzleIndex) {
            const puzzle = puzzles[puzzleIndex];
            const newHeight = puzzle.width;
            const newWidth = puzzle.height;
            const newShape = Array(newHeight).fill(null).map(() => Array(newWidth).fill(false));
            
            for (let i = 0; i < puzzle.height; i++) {
                for (let j = 0; j < puzzle.width; j++) {
                    if (puzzle.shape[i][j]) {
                        newShape[j][newWidth - 1 - i] = true;
                    }
                }
            }
            
            puzzle.width = newWidth;
            puzzle.height = newHeight;
            puzzle.shape = newShape;
            renderPuzzleList();
        }



        function removePuzzle(index) {
            puzzles.splice(index, 1);
            puzzles.forEach((p, i) => p.id = i);
            renderPuzzleList();
        }

        function getPuzzleCells(puzzle) {
            const cells = [];
            for (let i = 0; i < puzzle.height; i++) {
                for (let j = 0; j < puzzle.width; j++) {
                    if (puzzle.shape[i][j]) {
                        cells.push({r: i, c: j});
                    }
                }
            }
            return cells;
        }

        function getAllRotations(puzzle) {
            const rotations = [];
            let current = {
                width: puzzle.width,
                height: puzzle.height,
                shape: puzzle.shape.map(row => [...row])
            };
            
            for (let r = 0; r < 4; r++) {
                rotations.push({
                    width: current.width,
                    height: current.height,
                    cells: getPuzzleCells(current)
                });
                
                const newHeight = current.width;
                const newWidth = current.height;
                const newShape = Array(newHeight).fill(null).map(() => Array(newWidth).fill(false));
                
                for (let i = 0; i < current.height; i++) {
                    for (let j = 0; j < current.width; j++) {
                        if (current.shape[i][j]) {
                            newShape[j][newWidth - 1 - i] = true;
                        }
                    }
                }
                
                current = {
                    width: newWidth,
                    height: newHeight,
                    shape: newShape
                };
            }
            
            const unique = [];
            const seen = new Set();
            rotations.forEach(rot => {
                const key = JSON.stringify(rot.cells);
                if (!seen.has(key)) {
                    seen.add(key);
                    unique.push(rot);
                }
            });
            
            return unique;
        }

        function canPlace(grid, puzzleRot, row, col, rows, cols, obstacles) {
            for (const cell of puzzleRot.cells) {
                const nr = row + cell.r;
                const nc = col + cell.c;
                if (nr < 0 || nr >= rows || nc < 0 || nc >= cols || grid[nr][nc] !== -1) {
                    return false;
                }
                if (obstacles && obstacles[nr][nc]) {
                    return false;
                }
            }
            return true;
        }

        function place(grid, puzzleRot, row, col, pieceId) {
            for (const cell of puzzleRot.cells) {
                grid[row + cell.r][col + cell.c] = pieceId;
            }
        }

        function unplace(grid, puzzleRot, row, col) {
            for (const cell of puzzleRot.cells) {
                grid[row + cell.r][col + cell.c] = -1;
            }
        }

        function checkConstraints(grid, rowConstraints, colConstraints, obstacles, preFilled) {
            const rows = grid.length;
            const cols = grid[0].length;
            
            for (let i = 0; i < rows; i++) {
                let count = 0;
                for (let j = 0; j < cols; j++) {
                    if (grid[i][j] !== -1 || (preFilled && preFilled[i][j])) count++;
                }
                if (count !== rowConstraints[i]) return false;
            }
            
            for (let j = 0; j < cols; j++) {
                let count = 0;
                for (let i = 0; i < rows; i++) {
                    if (grid[i][j] !== -1 || (preFilled && preFilled[i][j])) count++;
                }
                if (count !== colConstraints[j]) return false;
            }
            
            return true;
        }

        function solve(grid, puzzleRots, used, puzzleIndex, rows, cols, rowConstraints, colConstraints, obstacles, preFilled) {
            if (puzzleIndex === puzzleRots.length) {
                return checkConstraints(grid, rowConstraints, colConstraints, obstacles, preFilled);
            }
            
            if (used[puzzleIndex]) {
                return solve(grid, puzzleRots, used, puzzleIndex + 1, rows, cols, rowConstraints, colConstraints, obstacles, preFilled);
            }
            
            for (const rot of puzzleRots[puzzleIndex]) {
                for (let r = -rot.height + 1; r < rows; r++) {
                    for (let c = -rot.width + 1; c < cols; c++) {
                        if (canPlace(grid, rot, r, c, rows, cols, obstacles)) {
                            place(grid, rot, r, c, puzzleIndex);
                            used[puzzleIndex] = true;
                            
                            if (solve(grid, puzzleRots, used, puzzleIndex + 1, rows, cols, rowConstraints, colConstraints, obstacles, preFilled)) {
                                return true;
                            }
                            
                            unplace(grid, rot, r, c);
                            used[puzzleIndex] = false;
                        }
                    }
                }
            }
            
            return false;
        }

        function solvePuzzle() {
            if (gridData.rows === 0 || gridData.cols === 0) {
                showStatus('请先创建网格', 'error');
                return;
            }
            
            if (puzzles.length === 0) {
                showStatus('请至少添加一个拼图', 'error');
                return;
            }
            
            const validPuzzles = puzzles.filter(p => getPuzzleCells(p).length > 0);
            if (validPuzzles.length === 0) {
                showStatus('请至少定义一个拼图形状', 'error');
                return;
            }
            
            const rows = gridData.rows;
            const cols = gridData.cols;
            const grid = Array(rows).fill(null).map(() => Array(cols).fill(-1));
            
            const puzzleRots = validPuzzles.map(p => getAllRotations(p));
            const used = new Array(validPuzzles.length).fill(false);
            
            showStatus('正在求解...', 'info');
            
            setTimeout(() => {
                const startTime = Date.now();
                const solved = solve(grid, puzzleRots, used, 0, rows, cols, gridData.rowConstraints, gridData.colConstraints, gridData.obstacles, gridData.preFilled);
                const endTime = Date.now();
                
                if (solved) {
                    showResult(grid, validPuzzles);
                    showStatus(`求解成功！用时 ${endTime - startTime}ms`, 'success');
                } else {
                    showStatus('无解，请检查约束条件和拼图', 'error');
                    document.getElementById('resultSection').classList.remove('show');
                }
            }, 100);
        }

        function showResult(grid, validPuzzles) {
            const container = document.getElementById('resultContainer');
            const rows = grid.length;
            const cols = grid[0].length;
            
            let html = `<div class="result-grid" style="grid-template-columns: repeat(${cols}, 42px);">`;
            
            const colors = ['piece-1', 'piece-2', 'piece-3', 'piece-4', 'piece-5', 'piece-6', 'piece-7', 'piece-8', 'piece-9', 'piece-10', 'piece-11', 'piece-12'];
            
            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < cols; j++) {
                    const pieceId = grid[i][j];
                    if (pieceId !== -1) {
                        const colorClass = colors[pieceId % colors.length];
                        html += `<div class="result-cell ${colorClass}">${pieceId + 1}</div>`;
                    } else if (gridData.obstacles[i][j]) {
                        html += `<div class="result-cell" style="background: repeating-linear-gradient(45deg, #a0aec0, #a0aec0 5px, #718096 5px, #718096 10px); border: 2px solid #4a5568;" title="障碍物"></div>`;
                    } else if (gridData.preFilled[i][j]) {
                        html += `<div class="result-cell" style="background: repeating-linear-gradient(-45deg, #68a391, #68a391 5px, #4a7c6f 5px, #4a7c6f 10px); border: 2px solid #3d6659; color: #fff; text-shadow: 1px 1px 2px rgba(0,0,0,0.3);" title="预填拼图">*</div>`;
                    } else {
                        html += `<div class="result-cell" style="background: #f7fafc; border: 2px dashed #e2e8f0;"></div>`;
                    }
                }
            }
            html += '</div>';
            
            html += '<div style="margin-top: 20px;"><strong style="font-size: 15px; color: #6b5b4f;">图例:</strong></div>';
            html += '<div style="display: flex; flex-wrap: wrap; gap: 10px; margin-top: 12px;">';
            validPuzzles.forEach((p, i) => {
                const colorClass = colors[i % colors.length];
                const pieceColors = [
                    'linear-gradient(135deg, #e8b4b4 0%, #d4a0a0 100%)',
                    'linear-gradient(135deg, #b4d4c8 0%, #a0c4b8 100%)',
                    'linear-gradient(135deg, #b4c8e8 0%, #a0b8d4 100%)',
                    'linear-gradient(135deg, #e8d4b4 0%, #d4c4a0 100%)',
                    'linear-gradient(135deg, #d4b4e8 0%, #c4a0d4 100%)',
                    'linear-gradient(135deg, #b4e8d4 0%, #a0d4c4 100%)',
                    'linear-gradient(135deg, #e8c8b4 0%, #d4b8a0 100%)',
                    'linear-gradient(135deg, #b4d4e8 0%, #a0c4d4 100%)',
                    'linear-gradient(135deg, #d4e8b4 0%, #c4d4a0 100%)',
                    'linear-gradient(135deg, #e8b4d4 0%, #d4a0c4 100%)',
                    'linear-gradient(135deg, #b4e8c8 0%, #a0d4b8 100%)',
                    'linear-gradient(135deg, #c8b4e8 0%, #b8a0d4 100%)'
                ];
                html += `<div class="legend-item">
                    <div class="legend-color" style="background: ${pieceColors[i % pieceColors.length]};"></div>
                    <span>拼图 ${i + 1} <small style="color: #8a7a6a;">(${getPuzzleCells(p).length}格)</small></span>
                </div>`;
            });
            
            const hasObstacles = gridData.obstacles.some(row => row.some(cell => cell));
            const hasPreFilled = gridData.preFilled.some(row => row.some(cell => cell));
            
            if (hasObstacles) {
                html += `<div class="legend-item">
                    <div class="legend-color" style="background: repeating-linear-gradient(45deg, #c8c0b8, #c8c0b8 3px, #b8b0a8 3px, #b8b0a8 6px);"></div>
                    <span>障碍物</span>
                </div>`;
            }
            if (hasPreFilled) {
                html += `<div class="legend-item">
                    <div class="legend-color" style="background: repeating-linear-gradient(-45deg, #a8c8b8, #a8c8b8 3px, #88b8a8 3px, #88b8a8 6px);"></div>
                    <span>预填拼图</span>
                </div>`;
            }
            html += '</div>';
            
            container.innerHTML = html;
            document.getElementById('resultSection').classList.add('show');
        }

        function showStatus(message, type) {
            const container = document.getElementById('statusMessage');
            container.innerHTML = `<div class="status-message status-${type}">${message}</div>`;
        }

        function clearAll() {
            gridData = {
                rows: 0,
                cols: 0,
                rowConstraints: [],
                colConstraints: [],
                obstacles: [],
                preFilled: []
            };
            puzzles = [];
            canvasData.cells = Array(canvasData.height).fill(null).map(() => Array(canvasData.width).fill(false));
            
            document.getElementById('gridContainer').innerHTML = '<p style="color: #718096; text-align: center;">请先创建网格</p>';
            document.getElementById('puzzleList').innerHTML = '';
            document.getElementById('resultSection').classList.remove('show');
            document.getElementById('statusMessage').innerHTML = '';
            renderCanvas();
        }

        window.onload = function() {
            createGrid();
            initCanvas();
        };
    </script>
</body>
</html>
